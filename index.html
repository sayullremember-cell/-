<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pink Gold Gallery Tree</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Times New Roman', serif; user-select: none; }
        
        /* 1. Loading */
        #loader { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #1a001a 0%, #000 100%);
            z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 1s; 
        }
        .spinner { 
            width: 70px; height: 70px; border: 2px solid rgba(255, 20, 147, 0.2); 
            border-top: 2px solid #ff1493; border-bottom: 2px solid #ffd700;
            border-radius: 50%; animation: spin 1s infinite linear; 
        }
        .loading-text { color: #ff69b4; margin-top: 25px; letter-spacing: 4px; font-size: 14px; font-weight: bold; }
        
        /* 2. UI */
        h1 { 
            position: absolute; top: 30px; width: 100%; text-align: center; 
            background: linear-gradient(to bottom, #fff, #ffb6c1, #ffd700); -webkit-background-clip: text; color: transparent;
            font-size: 48px; text-shadow: 0 0 30px rgba(255, 105, 180, 0.8); z-index: 10; pointer-events: none; margin: 0;
        }

        #controls { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10; 
            display: flex; flex-direction: column; align-items: center; gap: 15px;
        }
        .btn-group { display: flex; gap: 20px; }
        .btn {
            background: rgba(0,0,0,0.6); border: 1px solid #ffd700; color: #ffd700;
            padding: 12px 30px; font-size: 14px; cursor: pointer; transition: 0.3s;
            border-radius: 30px; backdrop-filter: blur(10px);
        }
        .btn:hover { background: #ffd700; color: #000; box-shadow: 0 0 30px #ffd700; }
        .tips { color: rgba(255, 182, 193, 0.6); font-size: 12px; }

        /* 3. AI å‡†æ˜Ÿ (æ ¸å¿ƒäº¤äº’åé¦ˆ) */
        #hand-cursor {
            position: absolute; width: 20px; height: 20px; 
            border: 2px solid #ff1493; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 100;
            display: none; box-shadow: 0 0 10px #ff1493; transition: background 0.2s, width 0.2s, height 0.2s;
        }
        #hand-cursor.pinched { background: #00ff00; border-color: #00ff00; width: 10px; height: 10px; }

        /* æ‘„åƒå¤´å°çª— */
        #webcam-view {
            position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px;
            border: 1px solid #333; opacity: 0; transition: opacity 0.5s; z-index: 5;
            transform: scaleX(-1); /* é•œåƒ */
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- æ ¸å¿ƒåº“ -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- AI åº“ -->
    <script type="importmap">
        { "imports": { "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm" } }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">PREPARING GALLERY...</div>
    </div>

    <h1>Merry Christmas</h1>
    
    <!-- æ‰‹åŠ¿å…‰æ ‡ -->
    <div id="hand-cursor"></div>

    <div id="controls">
        <div class="btn-group">
            <button class="btn" onclick="setMode('TREE')">ğŸ„ TREE MODE</button>
            <button class="btn" onclick="setMode('WALL')">ğŸ–¼ï¸ PHOTO WALL</button>
            <button class="btn" onclick="document.getElementById('file-input').click()">ğŸ“· UPLOAD</button>
        </div>
        <div class="tips" id="status-text">Mouse: Drag to Rotate/Slide â€¢ Click to Focus</div>
        <input type="file" id="file-input" accept="image/*" style="display:none;" />
    </div>

    <video id="webcam-view" autoplay playsinline></video>

    <script>
        // === 1. å¼ºåˆ¶ç§»é™¤ Loading ===
        setTimeout(() => {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(() => l.remove(), 1000); }
        }, 4000);

        // === 2. å…¨å±€å˜é‡ ===
        let scene, camera, renderer, composer, mainGroup;
        let particles = [], photos = []; 
        let mode = 'TREE'; // TREE, WALL, FOCUS
        let time = 0;
        
        // äº¤äº’çŠ¶æ€
        let scrollOffset = 0; // ç…§ç‰‡å¢™çš„æ»‘åŠ¨åç§»é‡
        let targetScroll = 0;
        let isDragging = false;
        let lastMouseX = 0;
        
        // AI çŠ¶æ€
        let aiHandX = 0.5, aiHandY = 0.5; // 0-1
        let isPinching = false;
        let isAiActive = false;
        let focusedPhotoIndex = -1;

        window.onload = function() {
            initScene();
            initAI();
        };

        function initScene() {
            if (typeof THREE === 'undefined') return;

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050005, 0.015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 55);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;
            document.body.appendChild(renderer.domElement);

            // ç¯å¢ƒä¸ç¯å…‰
            setupLighting();

            // å†…å®¹
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            createParticles();
            createInitialPhotos(); // é¢„ç½® 12 å¼ ç…§ç‰‡

            // åæœŸ
            if (THREE.EffectComposer) {
                const renderPass = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.15; bloomPass.strength = 1.6; bloomPass.radius = 0.8;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
            }

            animate();
            
            // äº‹ä»¶ç»‘å®š
            window.addEventListener('resize', onResize);
            // é¼ æ ‡æ‹–æ‹½é€»è¾‘
            document.addEventListener('mousedown', e => { isDragging = true; lastMouseX = e.clientX; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            document.getElementById('file-input').addEventListener('change', onUpload);

            // ç§»é™¤ Loading
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
        }

        function setupLighting() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambient);
            const goldSpot = new THREE.SpotLight(0xffd700, 2);
            goldSpot.position.set(30, 50, 30);
            scene.add(goldSpot);
            const pinkSpot = new THREE.SpotLight(0xff1493, 2);
            pinkSpot.position.set(-30, 20, -30);
            scene.add(pinkSpot);
            
            // å‡åå°„
            const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=256;
            const ctx = cvs.getContext('2d');
            const g = ctx.createLinearGradient(0,0,0,256);
            g.addColorStop(0,'#fff'); g.addColorStop(0.5,'#ffd700'); g.addColorStop(1,'#000');
            ctx.fillStyle=g; ctx.fillRect(0,0,256,256);
            const tex = new THREE.CanvasTexture(cvs);
            tex.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = tex;
        }

        function createParticles() {
            const geo = new THREE.OctahedronGeometry(0.2);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.1, metalness: 0.8 });
            
            for(let i=0; i<1500; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                
                // æ ‘å½¢ç›®æ ‡ä½ç½®
                const t = i/1500; 
                const angle = t * 50 * Math.PI;
                const h = t * 40 - 20;
                const r = 12 * (1-Math.pow(t,0.8));
                
                mesh.userData = {
                    treePos: new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r),
                    wallPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*60, -20), // èƒŒæ™¯å¢™
                    speed: Math.random()*0.02,
                    phase: Math.random()*Math.PI*2
                };
                mainGroup.add(mesh);
                particles.push(mesh);
            }
        }

        function createInitialPhotos() {
            // åˆ›å»º 12 ä¸ªä¸åŒé¢œè‰²çš„è‰²å—ä½œä¸ºé»˜è®¤ç…§ç‰‡
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#ffaa00', '#aa00ff', '#00ffaa', '#ffaaaa', '#aaffaa'];
            
            colors.forEach((c, i) => {
                const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=320;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = c; ctx.fillRect(0,0,256,320);
                ctx.fillStyle = '#000'; ctx.font='40px serif'; ctx.textAlign='center';
                ctx.fillText("Photo " + (i+1), 128, 160);
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                addPhoto(tex, i);
            });
        }

        function addPhoto(texture, index) {
            const geo = new THREE.BoxGeometry(4, 5, 0.2);
            const matFrame = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1.0 });
            const matPic = new THREE.MeshBasicMaterial({ map: texture });
            const mesh = new THREE.Mesh(geo, [matFrame, matFrame, matFrame, matFrame, matPic, matFrame]);
            
            mesh.userData = {
                type: 'PHOTO',
                id: photos.length, // ä½¿ç”¨å½“å‰é•¿åº¦ä½œä¸ºID
                treePos: new THREE.Vector3(
                    Math.cos(index*0.5)*14, 
                    (index/12)*30 - 15, 
                    Math.sin(index*0.5)*14
                ),
                // å¢™æ¨¡å¼ä½ç½®ï¼šçº¿æ€§æ’åˆ—
                wallIndex: photos.length 
            };
            
            mainGroup.add(mesh);
            photos.push(mesh);
            particles.push(mesh); // æŠŠç…§ç‰‡ä¹ŸåŠ å…¥ç²’å­æ•°ç»„ç»Ÿä¸€ç®¡ç†
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. æ»šåŠ¨é€»è¾‘ (é˜»å°¼æ•ˆæœ)
            scrollOffset += (targetScroll - scrollOffset) * 0.1;

            // 2. æ•´ä½“æ—‹è½¬
            if(mode === 'TREE') {
                mainGroup.rotation.y += 0.002; // è‡ªè½¬
            } else {
                // å¢™æ¨¡å¼ä¸‹ï¼Œæ ¹æ®æ»šåŠ¨åç§»è°ƒæ•´æ•´ä½“ä½ç½®ï¼Œæ¨¡æ‹Ÿæ»‘åŠ¨
                mainGroup.rotation.y += (0 - mainGroup.rotation.y) * 0.1; // å›æ­£
                // é™åˆ¶æ»šåŠ¨èŒƒå›´
                if(targetScroll > 0) targetScroll = 0;
                if(targetScroll < -(photos.length * 6)) targetScroll = -(photos.length * 6);
            }

            // 3. ç²’å­/ç…§ç‰‡æ›´æ–°
            particles.forEach(p => {
                let target = new THREE.Vector3();
                let targetScale = new THREE.Vector3(1,1,1);
                let targetRot = new THREE.Euler(0,0,0);

                if (mode === 'FOCUS' && p.userData.type === 'PHOTO') {
                    if (p.userData.id === focusedPhotoIndex) {
                        // èšç„¦æ€ï¼šé£åˆ°ç›¸æœºå‰
                        // è®¡ç®—ç›¸æœºå‰æ–¹çš„ä¸–ç•Œåæ ‡
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        target.copy(camera.position).add(camDir.multiplyScalar(8)); // è·ç¦»ç›¸æœº8å•ä½
                        targetRot.copy(camera.rotation);
                        targetScale.set(1.5, 1.5, 1.5);
                    } else {
                        // å…¶ä»–ç…§ç‰‡é€€å
                        target.copy(p.userData.treePos).multiplyScalar(1.5);
                    }
                } else if (mode === 'WALL' && p.userData.type === 'PHOTO') {
                    // å¢™æ¨¡å¼ï¼šæ’æˆä¸€æ’
                    // x = index * é—´éš” + æ»šåŠ¨åç§»
                    const x = (p.userData.wallIndex * 6) + scrollOffset - 10; 
                    target.set(x, 0, 0);
                    // ç®€å•çš„ Cover Flow æ•ˆæœï¼šä¸­é—´çš„å¤§ï¼Œä¸¤è¾¹çš„å°å¹¶æ—‹è½¬
                    const distToCenter = Math.abs(x);
                    if (distToCenter < 10) {
                        target.z = 5 - distToCenter * 0.5; // å‡¸èµ·
                        targetScale.set(1.2, 1.2, 1.2);
                    } else {
                        target.z = 0;
                    }
                } else if (mode === 'TREE') {
                    target.copy(p.userData.treePos);
                    // æ ‘æ¨¡å¼ä¸‹ç…§ç‰‡ä¹Ÿè¦æ—‹è½¬å¯¹é½åœ†å¿ƒ
                    if(p.userData.type === 'PHOTO') {
                        targetRot.y = Math.atan2(target.x, target.z);
                    }
                } else {
                    // æ•£å¼€èƒŒæ™¯
                    target.copy(p.userData.wallPos || p.position);
                }

                // æ’å€¼ç§»åŠ¨
                p.position.lerp(target, 0.08);
                p.scale.lerp(targetScale, 0.08);
                if(p.userData.type === 'PHOTO') {
                    // ç®€å•çš„æ—‹è½¬æ’å€¼
                    p.rotation.x += (targetRot.x - p.rotation.x) * 0.1;
                    p.rotation.y += (targetRot.y - p.rotation.y) * 0.1;
                    p.rotation.z += (targetRot.z - p.rotation.z) * 0.1;
                } else {
                    p.rotation.x += 0.01; p.rotation.y += 0.01; // ç²’å­è‡ªè½¬
                }
            });

            if(composer) composer.render();
            else renderer.render(scene, camera);
        }

        // === äº¤äº’é€»è¾‘ ===
        function onMouseMove(e) {
            // å¦‚æœ AI æ¿€æ´»ï¼Œä¼˜å…ˆç”¨ AI æ•°æ®
            if(isAiActive) return;

            const deltaX = e.clientX - lastMouseX;
            lastMouseX = e.clientX;

            if (isDragging) {
                if (mode === 'WALL') {
                    targetScroll += deltaX * 0.05; // é¼ æ ‡æ‹–æ‹½æ»‘åŠ¨
                } else if (mode === 'TREE') {
                    mainGroup.rotation.y += deltaX * 0.005; // é¼ æ ‡æ‹–æ‹½æ—‹è½¬æ ‘
                }
            }
        }

        function onClick(e) {
            // ç‚¹å‡»å±å¹•ä¸­å¿ƒé™„è¿‘ï¼Œæ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†ç…§ç‰‡
            // è¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åšä¸€ä¸ªç®€å•çš„å°„çº¿æ£€æµ‹é€»è¾‘
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photos);

            if (intersects.length > 0) {
                const clickedPhoto = intersects[0].object;
                focusedPhotoIndex = clickedPhoto.userData.id;
                mode = 'FOCUS'; // ç‚¹å‡»èšç„¦
                document.getElementById('status-text').innerText = "Mode: FOCUS (Click background to return)";
            } else {
                if (mode === 'FOCUS') mode = 'WALL'; // ç‚¹å‡»èƒŒæ™¯é€€å‡ºèšç„¦
                else if (mode === 'TREE') mode = 'WALL'; // ç‚¹å‡»åˆ‡æ¢åˆ°å¢™
                else if (mode === 'WALL') mode = 'TREE';
                
                document.getElementById('status-text').innerText = `Mode: ${mode}`;
            }
        }

        function onUpload(e) {
            const f = e.target.files[0];
            if(!f) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                new THREE.TextureLoader().load(ev.target.result, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    addPhoto(tex, photos.length); // åŠ åˆ°é˜Ÿå°¾
                    mode = 'WALL'; // è‡ªåŠ¨åˆ‡åˆ°å¢™æ¨¡å¼æŸ¥çœ‹
                    targetScroll = -((photos.length-1) * 6); // æ»šåŠ¨åˆ°æœ€æ–°
                });
            };
            reader.readAsDataURL(f);
        }

        window.setMode = (m) => { 
            mode = m; 
            document.getElementById('status-text').innerText = `Mode: ${mode}`;
        };
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        // === AI æ¨¡å— ===
        async function initAI() {
            const cursor = document.getElementById('hand-cursor');
            const video = document.getElementById('webcam-view');
            const statusText = document.getElementById('status-text');

            try {
                const { FilesetResolver, HandLandmarker } = await import('@mediapipe/tasks-vision');
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                const landmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO", numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                
                video.addEventListener("loadeddata", () => {
                    isAiActive = true;
                    video.style.opacity = 0.5; // æ˜¾ç¤ºå°çª—
                    cursor.style.display = 'block'; // æ˜¾ç¤ºå…‰æ ‡
                    statusText.innerText = "âœ¨ AI Ready! Pinch to Select, Move to Slide âœ¨";
                    statusText.style.color = "#55ff55";

                    function predict() {
                        requestAnimationFrame(predict);
                        const result = landmarker.detectForVideo(video, performance.now());
                        
                        if (result.landmarks && result.landmarks.length > 0) {
                            const hand = result.landmarks[0];
                            // 1. æ›´æ–°å…‰æ ‡ä½ç½® (é•œåƒç¿»è½¬)
                            // å±å¹•åæ ‡æ˜ å°„
                            const x = (1 - hand[9].x) * window.innerWidth;
                            const y = hand[9].y * window.innerHeight;
                            cursor.style.left = x + 'px';
                            cursor.style.top = y + 'px';

                            // 2. æ£€æµ‹æåˆ
                            const thumb = hand[4]; 
                            const index = hand[8];
                            const dist = Math.hypot(thumb.x-index.x, thumb.y-index.y);
                            const wasPinching = isPinching;
                            isPinching = dist < 0.08;

                            // è§†è§‰åé¦ˆ
                            if (isPinching) cursor.classList.add('pinched');
                            else cursor.classList.remove('pinched');

                            // 3. é€»è¾‘è§¦å‘
                            if (isPinching && !wasPinching) {
                                // åˆšæä¸‹ (Trigger Click)
                                const clickEvent = new MouseEvent('click', {
                                    clientX: x,
                                    clientY: y
                                });
                                document.dispatchEvent(clickEvent); // è§¦å‘ç‚¹å‡»æ£€æµ‹
                            }

                            // 4. æ‚¬åœ/æ»‘åŠ¨é€»è¾‘
                            if (mode === 'WALL' && isPinching) {
                                // æä½æ»‘åŠ¨
                                targetScroll -= (x - lastMouseX) * 0.1; // ç®€å•çš„ä½ç§»æ˜ å°„
                            }
                            
                            // æ›´æ–°ä¸Šä¸€æ¬¡ä½ç½®ç”¨äºè®¡ç®—é€Ÿåº¦
                            lastMouseX = x;
                        }
                    }
                    predict();
                });
            } catch (e) {
                console.log("AI Init Failed", e);
                statusText.innerText = "AI Failed. Please use Mouse.";
            }
        }
    </script>
</body>
</html>
