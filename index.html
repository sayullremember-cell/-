<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pink Gold Tree (Interactive)</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Times New Roman', serif; user-select: none; }
        
        /* 1. Loading ÁïåÈù¢ */
        #loader { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #1a001a 0%, #000 100%);
            z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 1s; 
        }
        .spinner { 
            width: 70px; height: 70px; border: 2px solid rgba(255, 20, 147, 0.2); 
            border-top: 2px solid #ff1493; border-bottom: 2px solid #ffd700;
            border-radius: 50%; animation: spin 1s infinite linear; 
        }
        .loading-text { color: #ff69b4; margin-top: 25px; letter-spacing: 2px; font-weight: bold; }
        
        /* 2. Ê†áÈ¢ò */
        h1 { 
            position: absolute; top: 20px; width: 100%; text-align: center; 
            background: linear-gradient(to bottom, #fff, #ffb6c1, #ffd700); -webkit-background-clip: text; color: transparent;
            font-size: 48px; text-shadow: 0 0 30px rgba(255, 105, 180, 0.8); z-index: 10; pointer-events: none; margin: 0;
        }

        /* 3. Â∫ïÈÉ®ÊåâÈíÆÂå∫ */
        #controls { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10; 
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        .btn {
            background: rgba(0,0,0,0.6); border: 1px solid #ffd700; color: #ffd700;
            padding: 10px 30px; font-size: 14px; cursor: pointer; transition: 0.3s;
            border-radius: 30px; backdrop-filter: blur(10px);
        }
        .btn:hover { background: #ffd700; color: #000; box-shadow: 0 0 30px #ffd700; }
        
        #ai-status { 
            color: #ffb6c1; font-size: 14px; text-shadow: 0 0 5px #ff1493; 
            background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 10px;
        }

        /* 4. ÊëÑÂÉèÂ§¥‚ÄúÈ≠îÈïú‚ÄùÁ™óÂè£ (Áé∞Âú®ÂèØËßÅ‰∫ÜÔºÅ) */
        #webcam-container {
            position: absolute; bottom: 20px; right: 20px; 
            width: 160px; height: 120px; 
            border: 2px solid #ffd700; border-radius: 10px;
            overflow: hidden; z-index: 20; opacity: 0; transition: opacity 1s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            background: #000;
        }
        #webcam {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); /* ÈïúÂÉèÁøªËΩ¨ */
        }
        .cam-label {
            position: absolute; bottom: 0; width: 100%; text-align: center;
            background: rgba(0,0,0,0.7); color: #fff; font-size: 10px; padding: 2px 0;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- Ê†∏ÂøÉÂ∫ì -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- AI Ê®°Âùó -->
    <script type="importmap">
        { "imports": { "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm" } }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">LOADING INTERACTIVE MAGIC...</div>
    </div>

    <h1>Merry Christmas</h1>
    
    <div id="controls">
        <button class="btn" onclick="document.getElementById('photo-input').click()">üì∑ ADD MEMORY</button>
        <div id="ai-status">Waiting for Camera...</div>
        <input type="file" id="photo-input" accept="image/*" style="display:none;" />
    </div>

    <!-- ÂèØËßÅÁöÑÊëÑÂÉèÂ§¥Á™óÂè£ -->
    <div id="webcam-container">
        <video id="webcam" autoplay playsinline></video>
        <div class="cam-label">AI VISION</div>
    </div>

    <script>
        // === Âº∫Âà∂ÁßªÈô§ Loading ===
        setTimeout(() => {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(() => l.remove(), 1000); }
        }, 3000);

        // === ÂÖ®Â±ÄÂèòÈáè ===
        let scene, camera, renderer, composer, mainGroup;
        let particles = [], photos = [];
        let mode = 'TREE'; 
        let time = 0;
        let mouseX = 0, mouseY = 0;
        let aiX = 0, aiY = 0;
        let isAiActive = false;
        let targetPhotoIndex = 0;

        window.onload = function() {
            initScene();
            initAI(); 
        };

        function initScene() {
            if (typeof THREE === 'undefined') return;

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050005, 0.015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 50);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.6;
            document.body.appendChild(renderer.domElement);

            // ÁéØÂ¢ÉË¥¥Âõæ
            const envC = document.createElement('canvas'); envC.width = 512; envC.height = 512;
            const ctx = envC.getContext('2d');
            const grd = ctx.createLinearGradient(0,0,0,512);
            grd.addColorStop(0, '#ffffff'); grd.addColorStop(0.2, '#ff1493'); 
            grd.addColorStop(0.5, '#ffd700'); grd.addColorStop(1, '#000000');
            ctx.fillStyle = grd; ctx.fillRect(0,0,512,512);
            const envMap = new THREE.CanvasTexture(envC);
            envMap.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envMap;

            // ÁÅØÂÖâ
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const goldSpot = new THREE.SpotLight(0xffd700, 2.5); goldSpot.position.set(30, 50, 30); scene.add(goldSpot);
            const pinkSpot = new THREE.SpotLight(0xff1493, 3); pinkSpot.position.set(-30, 20, -30); scene.add(pinkSpot);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            createLuxuryTree();
            createStardust();

            // ËæâÂÖâ
            if (THREE.EffectComposer) {
                const renderPass = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.15; bloomPass.strength = 1.8; bloomPass.radius = 0.7;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
            }

            animate();
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            document.getElementById('photo-input').addEventListener('change', onPhotoUpload);

            // ÁßªÈô§ loading
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
        }

        function createLuxuryTree() {
            const matPink = new THREE.MeshStandardMaterial({ color: 0xff1493, roughness: 0.05, metalness: 0.95, envMapIntensity: 1.5, emissive: 0x330011, emissiveIntensity: 0.2 });
            const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.02, metalness: 1.0, envMapIntensity: 2.0, emissive: 0x332200, emissiveIntensity: 0.2 });
            const geoDiamond = new THREE.OctahedronGeometry(0.35); 
            const geoSphere = new THREE.SphereGeometry(0.4, 16, 16);

            // ÈªòËÆ§ÁÖßÁâá
            const defaultPhoto = createDefaultPhotoTexture();
            addPhotoToScene(defaultPhoto, true);

            for(let i=0; i<2500; i++) {
                const isGold = Math.random() > 0.75;
                const mesh = new THREE.Mesh(isGold ? geoSphere : geoDiamond, isGold ? matGold : matPink);
                const t = i / 2500;
                const angle = t * 60 * Math.PI;
                const h = t * 38 - 18;
                const r = 14 * (1 - Math.pow(t, 0.7));
                
                mesh.position.set( (Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80 ); 
                
                mesh.userData = {
                    treePos: new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r),
                    scatterPos: mesh.position.clone(),
                    speed: Math.random() * 0.03 + 0.01,
                    blinkOffset: Math.random() * 100
                };
                mainGroup.add(mesh);
                particles.push(mesh);
            }
        }
        
        function addPhotoToScene(texture, isTopper = false) {
            const matFrame = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1.0 });
            const matPic = new THREE.MeshBasicMaterial({ map: texture });
            
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 3.6, 0.2), [
                matFrame, matFrame, matFrame, matFrame, matPic, matFrame
            ]);
            
            if (isTopper) {
                mesh.userData = { type: 'PHOTO', treePos: new THREE.Vector3(0, 19, 0), scatterPos: new THREE.Vector3(0, 40, 0), speed: 0.01, blinkOffset: 0 };
            } else {
                const t = Math.random(); const angle = Math.random() * 60 * Math.PI;
                const h = t * 30 - 15; const r = 14 * (1-t) + 1;
                mesh.userData = { type: 'PHOTO', treePos: new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r), scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80), speed: 0.01, blinkOffset: 0 };
            }
            
            mainGroup.add(mesh);
            particles.push(mesh);
            photos.push(mesh);
        }

        function createDefaultPhotoTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#110011'; ctx.fillRect(0,0,256,256);
            ctx.fillStyle = '#ffd700'; ctx.font = 'bold 30px serif';
            ctx.textAlign = 'center'; ctx.fillText("JOYEUX", 128, 100); ctx.fillText("NOEL", 128, 150);
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; return tex;
        }

        function createStardust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*80, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffb6c1, size: 0.2, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            scene.add(new THREE.Points(geo, mat));
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // ÊóãËΩ¨ÈÄªËæë (AI ‰ºòÂÖà)
            let targetX = isAiActive ? aiX : mouseY * 0.3;
            let targetY = isAiActive ? aiY : mouseX * 0.5;
            mainGroup.rotation.y += 0.002; 
            mainGroup.rotation.y += (targetY - mainGroup.rotation.y) * 0.1; // Âä†Âø´ÂìçÂ∫îÈÄüÂ∫¶
            mainGroup.rotation.x += (targetX - mainGroup.rotation.x) * 0.1;

            particles.forEach((p, i) => {
                p.rotation.x += p.userData.speed; p.rotation.y += p.userData.speed;
                const blink = Math.sin(time * 3 + p.userData.blinkOffset);
                if (blink > 0.8) {
                    p.scale.setScalar(1.5); if(p.material.emissiveIntensity) p.material.emissiveIntensity = 1.0;
                } else {
                    p.scale.setScalar(1.0); if(p.material.emissiveIntensity) p.material.emissiveIntensity = 0.2;
                }
                
                if (mode === 'FOCUS' && p.userData.type === 'PHOTO') {
                    if (photos.indexOf(p) === targetPhotoIndex) {
                        p.position.lerp(new THREE.Vector3(0,2,40), 0.1); // Âä†Âø´È£ûÊù•ÈÄüÂ∫¶
                        p.lookAt(camera.position);
                        p.scale.lerp(new THREE.Vector3(4,4,4), 0.1);
                        return;
                    }
                }
                const target = mode === 'TREE' ? p.userData.treePos : p.userData.scatterPos;
                p.position.lerp(target, 0.06);
            });

            if(composer) composer.render();
            else renderer.render(scene, camera);
        }

        function onMouseMove(e) {
            if (!isAiActive) { 
                mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
                mouseY = (e.clientY / window.innerHeight - 0.5) * 1;
            }
        }
        function onMouseClick() {
            if (isAiActive) return; 
            const modes = ['TREE', 'SCATTER', 'FOCUS'];
            mode = modes[(modes.indexOf(mode) + 1) % modes.length];
            if(mode === 'FOCUS') targetPhotoIndex = Math.floor(Math.random() * photos.length);
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }
        function onPhotoUpload(e) {
            const f = e.target.files[0];
            if(!f) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                new THREE.TextureLoader().load(ev.target.result, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    addPhotoToScene(tex);
                });
            };
            reader.readAsDataURL(f);
        }

        // --- AI Ê®°Âùó ---
        async function initAI() {
            const statusEl = document.getElementById('ai-status');
            const camContainer = document.getElementById('webcam-container');
            
            try {
                const { FilesetResolver, HandLandmarker } = await import('@mediapipe/tasks-vision');
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                const landmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO", numHands: 1
                });

                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                
                video.addEventListener("loadeddata", () => {
                    isAiActive = true;
                    camContainer.style.opacity = 1; // ÊòæÁ§∫ÊëÑÂÉèÂ§¥
                    statusEl.innerText = "‚ú® AI Active: Pinch to Focus | Release to Tree ‚ú®";
                    statusEl.style.color = "#00ff00";

                    function predict() {
                        requestAnimationFrame(predict);
                        const result = landmarker.detectForVideo(video, performance.now());
                        if (result.landmarks[0]) {
                            const hand = result.landmarks[0];
                            const palm = hand[9];
                            // ÊèêÈ´òÁÅµÊïèÂ∫¶Ôºö*4
                            aiY = (palm.x - 0.5) * 4; 
                            aiX = (palm.y - 0.5) * 3;
                            
                            const thumb = hand[4]; const index = hand[8];
                            const dist = Math.hypot(thumb.x-index.x, thumb.y-index.y);
                            
                            // ÊçèÂêàÊ£ÄÊµã
                            if (dist < 0.1) { // ÈòàÂÄºÊîæÂÆΩÂà∞ 0.1ÔºåÊõ¥ÂÆπÊòìËß¶Âèë
                                if (mode !== 'FOCUS') {
                                    mode = 'FOCUS';
                                    targetPhotoIndex = Math.floor(Math.random() * photos.length);
                                }
                            } else {
                                mode = 'TREE'; // ÊùæÂºÄÂõûÊ†ë
                            }
                        }
                    }
                    predict();
                });
            } catch (e) {
                statusEl.innerText = "AI Offline. Click screen to interact.";
            }
        }
    </script>
</body>
</html>
