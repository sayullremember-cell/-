<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pink Diamond Gallery Tree</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Times New Roman', serif; user-select: none; }
        
        /* 1. æå…‰ Loading */
        #loader { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle at center, #1a001a 0%, #000 100%);
            z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; 
        }
        .spinner { 
            width: 80px; height: 80px; 
            border: 2px solid rgba(255, 105, 180, 0.1); 
            border-top: 4px solid #ff1493; border-bottom: 4px solid #ffd700;
            border-radius: 50%; animation: spin 0.8s infinite linear; 
            box-shadow: 0 0 50px rgba(255, 20, 147, 0.4);
        }
        .loading-text { color: #ffb6c1; margin-top: 20px; font-size: 12px; letter-spacing: 4px; font-weight: bold; }
        
        /* 2. æ ‡é¢˜ä¸UI */
        h1 { 
            position: absolute; top: 30px; width: 100%; text-align: center; 
            background: linear-gradient(to bottom, #fff 0%, #ff69b4 50%, #ffd700 100%); -webkit-background-clip: text; color: transparent;
            font-size: 52px; text-shadow: 0 0 40px rgba(255, 20, 147, 0.6); z-index: 10; pointer-events: none; margin: 0;
        }

        #controls { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10; 
            display: flex; flex-direction: column; align-items: center; gap: 15px;
        }
        .btn-group { display: flex; gap: 15px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 30px; backdrop-filter: blur(5px); border: 1px solid #333; }
        .btn {
            background: transparent; border: 1px solid rgba(255, 182, 193, 0.3); color: #ffb6c1;
            padding: 8px 20px; font-size: 12px; cursor: pointer; transition: 0.2s; border-radius: 20px;
        }
        .btn:hover, .btn.active { background: #ff1493; color: #fff; border-color: #ff1493; box-shadow: 0 0 15px #ff1493; }
        
        .tips { color: rgba(255, 255, 255, 0.4); font-size: 12px; margin-top: 5px; }

        /* 3. AI å…‰æ ‡ */
        #cursor {
            position: absolute; width: 20px; height: 20px; border: 2px solid #00ff00; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 100;
            box-shadow: 0 0 10px #00ff00; transition: width 0.1s, height 0.1s;
        }
        #cursor.pinched { background: #00ff00; width: 10px; height: 10px; }

        /* æ‘„åƒå¤´å°çª— */
        #webcam-view {
            position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px;
            border: 2px solid #333; opacity: 0; transition: opacity 0.5s; z-index: 5;
            transform: scaleX(-1); border-radius: 8px;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- æ ¸å¿ƒåº“ -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- AI åº“ -->
    <script type="importmap">
        { "imports": { "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm" } }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">RESTORING BEAUTY...</div>
    </div>

    <h1>Merry Christmas</h1>
    
    <!-- AI å…‰æ ‡ -->
    <div id="cursor"></div>

    <div id="controls">
        <div class="btn-group">
            <button class="btn active" id="btn-tree" onclick="setMode('TREE')">ğŸ„ TREE</button>
            <button class="btn" id="btn-wall" onclick="setMode('WALL')">ğŸ–¼ï¸ PHOTO WALL</button>
            <button class="btn" onclick="document.getElementById('file-input').click()">ğŸ“· ADD</button>
        </div>
        <div class="tips" id="status-text">Drag to Rotate/Slide â€¢ Click Photo to Focus</div>
        <input type="file" id="file-input" accept="image/*" style="display:none;" />
    </div>

    <video id="webcam-view" autoplay playsinline></video>

    <script>
        // === 1. å¼ºåˆ¶ç§»é™¤ Loading ===
        setTimeout(() => {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(() => l.remove(), 1000); }
        }, 4000);

        // === 2. å…¨å±€å˜é‡ ===
        let scene, camera, renderer, composer, mainGroup;
        let particles = [], photos = []; 
        let mode = 'TREE'; 
        let time = 0;
        
        // äº¤äº’çŠ¶æ€
        let isDragging = false;
        let lastMouseX = 0;
        let rotationVelocity = 0;
        let scrollOffset = 0;
        let targetScroll = 0;
        
        // AI
        let isAiActive = false;
        let focusedPhotoIndex = -1;

        window.onload = function() {
            initScene();
            initAI();
        };

        function initScene() {
            if (typeof THREE === 'undefined') return;

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050005, 0.02); // é›¾æ°”åŠ æ·±ï¼Œçªå‡ºä¸»ä½“

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 50);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.8; // æ›å…‰æ‹‰é«˜ï¼Œæ›´äº®
            document.body.appendChild(renderer.domElement);

            // === æ ¸å¿ƒï¼šæ‰‹åŠ¨åˆ›å»ºé«˜çº§ç¯å¢ƒåå°„ ===
            const envC = document.createElement('canvas'); envC.width = 512; envC.height = 512;
            const ctx = envC.getContext('2d');
            const grd = ctx.createLinearGradient(0,0,0,512);
            grd.addColorStop(0, '#ffffff');   // é¡¶å…‰
            grd.addColorStop(0.3, '#ff1493'); // ç²‰è‰²é«˜å…‰
            grd.addColorStop(0.6, '#ffd700'); // é‡‘è‰²ç¯å¢ƒ
            grd.addColorStop(1, '#000000');   // åº•éƒ¨æš—éƒ¨
            ctx.fillStyle = grd; ctx.fillRect(0,0,512,512);
            const envMap = new THREE.CanvasTexture(envC);
            envMap.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envMap;

            // === ç¯å…‰ ===
            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);
            const goldSpot = new THREE.SpotLight(0xffd700, 2.5);
            goldSpot.position.set(30, 50, 30); scene.add(goldSpot);
            const pinkSpot = new THREE.SpotLight(0xff1493, 2.5);
            pinkSpot.position.set(-30, 20, -30); scene.add(pinkSpot);
            const backlight = new THREE.PointLight(0x00ffff, 1, 50); // èƒŒå…‰è½®å»“
            backlight.position.set(0, 10, -30); scene.add(backlight);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            // æ„å»ºæ¼‚äº®çš„æ ‘
            createLuxuryTree();
            // é¢„ç½®å‡ å¼ ç…§ç‰‡
            createInitialPhotos();

            // === åæœŸè¾‰å…‰ ===
            if (THREE.EffectComposer) {
                const renderPass = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.1; // ææ˜“å‘å…‰
                bloomPass.strength = 1.6;  // å¼ºåº¦é«˜
                bloomPass.radius = 0.8;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
            }

            animate();
            
            // äº¤äº’äº‹ä»¶
            window.addEventListener('resize', onResize);
            document.addEventListener('mousedown', onPointerDown);
            document.addEventListener('touchstart', onPointerDown, {passive: false});
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchend', onPointerUp);
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('touchmove', onPointerMove, {passive: false});
            document.addEventListener('click', onClick);
            document.getElementById('file-input').addEventListener('change', onUpload);

            // Remove loader
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
        }

        // === æ ¸å¿ƒï¼šæ¢å¤â€œæ¼‚äº®çš„æ ‘â€ (Pink Diamonds + Gold Ornaments) ===
        function createLuxuryTree() {
            // æè´¨ï¼šé«˜åå…‰ã€è‡ªå‘å…‰
            const matPink = new THREE.MeshStandardMaterial({ 
                color: 0xff1493, roughness: 0.05, metalness: 0.95, envMapIntensity: 1.5,
                emissive: 0x330011, emissiveIntensity: 0.2
            });
            const matGold = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, roughness: 0.02, metalness: 1.0, envMapIntensity: 2.0,
                emissive: 0x332200, emissiveIntensity: 0.2
            });

            const geoDiamond = new THREE.OctahedronGeometry(0.3); // é’»çŸ³å½¢çŠ¶
            const geoSphere = new THREE.SphereGeometry(0.4, 16, 16); // åœ†çƒ

            // æ ‘é¡¶æ˜Ÿ
            const topGeo = new THREE.IcosahedronGeometry(1.5);
            const topMat = new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 1});
            const topper = new THREE.Mesh(topGeo, topMat);
            topper.position.y = 19;
            mainGroup.add(topper);
            const topLight = new THREE.PointLight(0xffaa00, 3, 20);
            topLight.position.y = 19;
            mainGroup.add(topLight);

            // ç²’å­ç”Ÿæˆ (3000ä¸ª)
            for(let i=0; i<3000; i++) {
                const isGold = Math.random() > 0.8; // 20% é‡‘è‰²è£…é¥°
                const mesh = new THREE.Mesh(isGold ? geoSphere : geoDiamond, isGold ? matGold : matPink);
                
                const t = i / 3000;
                const angle = t * 60 * Math.PI; // 30åœˆ
                const h = t * 38 - 18;
                const r = 14 * (1 - Math.pow(t, 0.7)); // é”¥å½¢

                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                // å¢åŠ ä¸€ç‚¹éšæœºæŠ–åŠ¨ï¼Œæ›´è‡ªç„¶
                const jitter = 0.5;
                mesh.position.set(x + (Math.random()-0.5)*jitter, h + (Math.random()-0.5)*jitter, z + (Math.random()-0.5)*jitter);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                mesh.userData = {
                    treePos: mesh.position.clone(), // è®°ä½æ ‘ä¸Šçš„ä½ç½®
                    // å¢™æ¨¡å¼ä½ç½®ï¼šç¨åè®¡ç®—
                    scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                    speed: Math.random() * 0.03 + 0.01,
                    blinkOffset: Math.random() * 100
                };
                
                mainGroup.add(mesh);
                particles.push(mesh);
            }
        }

        // === ç…§ç‰‡é€»è¾‘ ===
        function createInitialPhotos() {
            // é¢„ç½® 6 å¼ ä¸åŒé¢œè‰²çš„â€œç…§ç‰‡â€
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff'];
            colors.forEach((c, i) => {
                const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=320;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = c; ctx.fillRect(0,0,256,320);
                ctx.fillStyle = '#000'; ctx.font='30px serif'; ctx.textAlign='center';
                ctx.fillText("Memory "+(i+1), 128, 160);
                const tex = new THREE.CanvasTexture(cvs);
                tex.colorSpace = THREE.SRGBColorSpace;
                addPhoto(tex, i);
            });
        }

        function addPhoto(texture, index) {
            // é‡‘è‰²ç›¸æ¡†
            const geo = new THREE.BoxGeometry(4, 5, 0.2);
            const matFrame = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1.0 });
            const matPic = new THREE.MeshBasicMaterial({ map: texture });
            
            const mesh = new THREE.Mesh(geo, [matFrame, matFrame, matFrame, matFrame, matPic, matFrame]);
            
            // æŒ‚åœ¨æ ‘ä¸Šçš„ä½ç½® (éšæœº)
            const angle = Math.random() * Math.PI * 2;
            const h = (Math.random() - 0.5) * 20;
            const r = 14 * (1 - (h+18)/38) + 1.5; // è¡¨é¢å‘å¤–ä¸€ç‚¹
            
            mesh.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
            mesh.lookAt(0, h, 0); // é¢å‘ä¸­å¿ƒ...
            mesh.rotation.y += Math.PI; // ...åè½¬é¢å‘å¤–

            mesh.userData = {
                type: 'PHOTO',
                id: photos.length,
                treePos: mesh.position.clone(),
                treeRot: mesh.rotation.clone(),
                wallIndex: photos.length // å¢™æ¨¡å¼çš„ç´¢å¼•
            };

            mainGroup.add(mesh);
            photos.push(mesh);
            particles.push(mesh); // åŠ å…¥åŠ¨ç”»å¾ªç¯
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. äº¤äº’å¹³æ»‘ (Damping)
            if (!isDragging) {
                // æƒ¯æ€§æ»‘åŠ¨
                rotationVelocity *= 0.95;
                if (mode === 'TREE') mainGroup.rotation.y += rotationVelocity + 0.002; // åŸºç¡€è‡ªè½¬
                if (mode === 'WALL') {
                    targetScroll += rotationVelocity * 2; // æƒ¯æ€§æ»šåŠ¨
                }
            }
            
            // å¢™æ¨¡å¼ï¼šå¹³æ»‘æ»šåŠ¨åˆ°ç›®æ ‡ä½ç½®
            if (mode === 'WALL') {
                scrollOffset += (targetScroll - scrollOffset) * 0.1;
                // é™åˆ¶èŒƒå›´
                const maxScroll = 0;
                const minScroll = -((photos.length-1) * 6);
                if (targetScroll > maxScroll + 5) targetScroll = maxScroll + 5; // å¼¹æ€§
                if (targetScroll < minScroll - 5) targetScroll = minScroll - 5;
            } else {
                // æ ‘æ¨¡å¼ï¼šå¤ä½
                mainGroup.position.x += (0 - mainGroup.position.x) * 0.1;
            }

            // 2. ç²’å­ä¸ç…§ç‰‡åŠ¨ç”»
            particles.forEach(p => {
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Euler();
                let targetScale = new THREE.Vector3(1,1,1);

                // é—ªçƒåŠ¨ç”» (æ‰€æœ‰ç²’å­)
                if (p.userData.type !== 'PHOTO') {
                    p.rotation.x += p.userData.speed; p.rotation.y += p.userData.speed;
                    const blink = Math.sin(time * 3 + p.userData.blinkOffset);
                    const s = blink > 0.8 ? 1.5 : 1.0;
                    p.scale.setScalar(s);
                }

                // æ¨¡å¼é€»è¾‘
                if (mode === 'FOCUS' && p.userData.type === 'PHOTO') {
                    if (p.userData.id === focusedPhotoIndex) {
                        // èšç„¦ï¼šé£åˆ°å±å¹•å‰
                        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                        targetPos.copy(camera.position).add(camDir.multiplyScalar(8));
                        targetRot.copy(camera.rotation);
                        targetScale.set(1.5, 1.5, 1.5);
                    } else {
                        // å…¶ä»–ç…§ç‰‡é€€å
                        targetPos.copy(p.userData.treePos).multiplyScalar(2); 
                    }
                } else if (mode === 'WALL' && p.userData.type === 'PHOTO') {
                    // å¢™æ¨¡å¼ï¼šæ’æ’å
                    // x = index * é—´è· + æ»šåŠ¨åç§»
                    const x = (p.userData.wallIndex * 6) + scrollOffset;
                    targetPos.set(x, 0, 15); // æ”¾åœ¨ z=15 ç¦»ç›¸æœºè¿‘ä¸€ç‚¹
                    targetRot.set(0, 0, 0);
                    
                    // Cover Flow æ•ˆæœ
                    const dist = Math.abs(x);
                    if (dist < 10) {
                        targetPos.z += (10 - dist) * 0.5; // ä¸­é—´å‡¸èµ·
                        targetScale.set(1.2, 1.2, 1.2);
                    }
                } else if (mode === 'TREE') {
                    // å›åˆ°æ ‘ä¸Š
                    targetPos.copy(p.userData.treePos);
                    if (p.userData.type === 'PHOTO') targetRot.copy(p.userData.treeRot);
                } else {
                    // æ•£å¼€èƒŒæ™¯ (WALLæ¨¡å¼ä¸‹çš„ç²’å­)
                    targetPos.copy(p.userData.scatterPos);
                }

                // æ’å€¼æ›´æ–°
                p.position.lerp(targetPos, 0.08);
                if (p.userData.type === 'PHOTO') {
                    p.rotation.x += (targetRot.x - p.rotation.x) * 0.1;
                    p.rotation.y += (targetRot.y - p.rotation.y) * 0.1;
                    p.rotation.z += (targetRot.z - p.rotation.z) * 0.1;
                    p.scale.lerp(targetScale, 0.1);
                }
            });

            if(composer) composer.render();
            else renderer.render(scene, camera);
        }

        // === äº¤äº’äº‹ä»¶å¤„ç† ===
        function onPointerDown(e) {
            isDragging = true;
            lastMouseX = e.clientX || e.touches[0].clientX;
            rotationVelocity = 0;
        }
        function onPointerMove(e) {
            // AI æ¿€æ´»æ—¶ä¸å“åº”é¼ æ ‡ç§»åŠ¨ï¼Œé¿å…å†²çª
            if (isAiActive) return;

            const cx = e.clientX || e.touches[0].clientX;
            const deltaX = cx - lastMouseX;
            lastMouseX = cx;

            if (isDragging) {
                // è®°å½•é€Ÿåº¦ç”¨äºæƒ¯æ€§
                rotationVelocity = deltaX * 0.005;
                if (mode === 'TREE') {
                    mainGroup.rotation.y += rotationVelocity * 2; // æ ‘ï¼šæ—‹è½¬
                } else if (mode === 'WALL') {
                    targetScroll += deltaX * 0.1; // å¢™ï¼šæ»‘åŠ¨
                }
            }
        }
        function onPointerUp() { isDragging = false; }

        function onClick(e) {
            if (isDragging) return; // æ‹–æ‹½æ—¶ä¸è§¦å‘ç‚¹å‡»
            
            // å°„çº¿æ£€æµ‹
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photos);

            if (intersects.length > 0) {
                // ç‚¹å‡»äº†ç…§ç‰‡
                focusedPhotoIndex = intersects[0].object.userData.id;
                setMode('FOCUS');
            } else {
                // ç‚¹å‡»èƒŒæ™¯
                if (mode === 'FOCUS') setMode('WALL');
            }
        }

        window.setMode = (m) => {
            mode = m;
            document.getElementById('btn-tree').className = mode === 'TREE' ? 'btn active' : 'btn';
            document.getElementById('btn-wall').className = mode === 'WALL' ? 'btn active' : 'btn';
            
            if (mode === 'WALL') {
                targetScroll = 0; // é‡ç½®æ»šåŠ¨
                scrollOffset = -20; // ç¨å¾®ä»å³è¾¹æ»‘å…¥çš„æ•ˆæœ
            }
        };

        function onUpload(e) {
            const f = e.target.files[0];
            if(!f) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                new THREE.TextureLoader().load(ev.target.result, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    addPhoto(tex, photos.length);
                    setMode('WALL');
                    // æ»šåŠ¨åˆ°æœ€æ–°çš„ä¸€å¼ 
                    setTimeout(() => targetScroll = -((photos.length-1) * 6), 100);
                });
            };
            reader.readAsDataURL(f);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        // === AI æ¨¡å— ===
        async function initAI() {
            const cursor = document.getElementById('cursor');
            const video = document.getElementById('webcam-view');
            const statusText = document.getElementById('status-text');

            try {
                const { FilesetResolver, HandLandmarker } = await import('@mediapipe/tasks-vision');
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                const landmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO", numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                
                video.addEventListener("loadeddata", () => {
                    isAiActive = true;
                    video.style.opacity = 0.5; // æ˜¾ç¤ºå°çª—
                    cursor.style.display = 'block';
                    statusText.innerText = "AI Ready! Pinch to Select, Move to Slide";
                    statusText.style.color = "#55ff55";

                    let lastX = 0;
                    function predict() {
                        requestAnimationFrame(predict);
                        const result = landmarker.detectForVideo(video, performance.now());
                        
                        if (result.landmarks && result.landmarks.length > 0) {
                            const hand = result.landmarks[0];
                            // å±å¹•æ˜ å°„
                            const x = (1 - hand[9].x) * window.innerWidth;
                            const y = hand[9].y * window.innerHeight;
                            
                            cursor.style.left = x + 'px';
                            cursor.style.top = y + 'px';

                            // æåˆæ£€æµ‹
                            const thumb = hand[4]; const index = hand[8];
                            const dist = Math.hypot(thumb.x-index.x, thumb.y-index.y);
                            const isPinching = dist < 0.08;

                            if (isPinching) cursor.classList.add('pinched');
                            else cursor.classList.remove('pinched');

                            // AI æ§åˆ¶é€»è¾‘
                            if (isPinching) {
                                // æä½æ—¶ï¼šæ¨¡æ‹Ÿç‚¹å‡»æˆ–æ‹–æ‹½
                                if (mode === 'WALL') {
                                    targetScroll -= (x - lastX) * 0.2; // æ»‘åŠ¨
                                } else if (mode === 'TREE') {
                                    mainGroup.rotation.y += (x - lastX) * 0.01; // æ—‹è½¬
                                }
                                
                                // å¦‚æœä¹‹å‰æ²¡æï¼Œç°åœ¨æäº† -> è§¦å‘ç‚¹å‡»
                                // (è¿™é‡Œç®€åŒ–ï¼ŒæŒç»­æä½è§†ä¸ºæ‹–æ‹½ï¼Œç¬é—´æåˆè§†ä¸ºç‚¹å‡»éœ€æ›´å¤æ‚é€»è¾‘ï¼Œæš‚ç•¥)
                            }
                            lastX = x;
                        }
                    }
                    predict();
                });
            } catch (e) {
                console.log("AI Init Failed", e);
            }
        }
    </script>
</body>
</html>
