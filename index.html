<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas - High End China Edition</title>
    
    <!-- Google Fonts (可选，加载失败不影响运行) -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root { --gold: #d4af37; --bg: #050505; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Times New Roman', serif; user-select: none; }
        
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        h1 { 
            font-family: 'Cinzel', serif; font-size: 50px; text-align: center; margin-top: 30px; 
            color: transparent; background: linear-gradient(to bottom, #fff, var(--gold));
            -webkit-background-clip: text; 
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.8));
            letter-spacing: 5px;
        }
        
        .loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; }
        .spinner { width: 40px; height: 40px; border: 2px solid #333; border-top: 2px solid var(--gold); border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 15px; }
        .loader-text { color: var(--gold); font-family: 'Cinzel', serif; letter-spacing: 2px; font-size: 12px; }
        
        .controls { position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: auto; }
        .btn { 
            background: rgba(0,0,0,0.5); border: 1px solid var(--gold); color: var(--gold); 
            padding: 10px 25px; cursor: pointer; font-family: 'Cinzel', serif; 
            backdrop-filter: blur(5px); transition: 0.3s;
        }
        .btn:hover { background: rgba(212, 175, 55, 0.2); box-shadow: 0 0 15px var(--gold); }

        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- 【关键】使用国内 Staticfile CDN 加载资源 (非 Module 模式) -->
    <!-- 1. 核心库 -->
    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    
    <!-- 2. 辉光特效依赖链 (必须按顺序加载) -->
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

</head>
<body>

    <div id="loader" class="loader">
        <div class="spinner"></div>
        <div class="loader-text">LOADING RESOURCES...</div>
    </div>

    <div id="ui-container">
        <h1>Merry Christmas</h1>
        <div class="controls">
            <button class="btn" onclick="app.toggleMode()">SWITCH MODE</button>
            <div style="margin-top:10px; font-size:10px; color:#666;">Drag to Rotate | Click to Explode</div>
        </div>
    </div>

    <script>
        // --- 应用程序逻辑 ---
        const App = function() {
            const config = {
                gold: 0xd4af37,
                red: 0xaa0000,
                green: 0x0f3d0f
            };
            
            let scene, camera, renderer, composer;
            let mainGroup, particles = [], photos = [];
            let mode = 'TREE'; // TREE, SCATTER
            let rotationTarget = { x: 0, y: 0 };
            
            // 初始化入口
            function init() {
                try {
                    // 检查库是否加载
                    if (typeof THREE === 'undefined') throw new Error("Three.js not loaded");

                    // 1. 场景
                    scene = new THREE.Scene();
                    scene.fog = new THREE.FogExp2(0x050505, 0.02);

                    // 2. 相机
                    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(0, 2, 50);

                    // 3. 渲染器 (开启物理光照计算)
                    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.toneMapping = THREE.ReinhardToneMapping;
                    renderer.toneMappingExposure = 1.2;
                    document.body.appendChild(renderer.domElement);

                    // 4. 生成简单的环境贴图 (让金属有反射)
                    generateEnvironment();

                    // 5. 创建内容
                    mainGroup = new THREE.Group();
                    scene.add(mainGroup);
                    createContent();
                    createLighting();

                    // 6. 后期处理 (辉光核心)
                    initPostProcessing();

                    // 7. 事件
                    bindEvents();

                    // 8. 开始动画
                    animate();

                    // 9. 关闭 Loading
                    setTimeout(() => {
                        document.getElementById('loader').style.opacity = 0;
                        setTimeout(() => document.getElementById('loader').remove(), 800);
                    }, 500);

                } catch (e) {
                    alert("Resource Load Error: " + e.message + ". Please refresh.");
                }
            }

            function generateEnvironment() {
                // 手动创建一个 CubeTexture 作为环境，不用下载 huge HDR
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0, 0, 0, 128);
                grad.addColorStop(0, '#443300'); // 顶部深金
                grad.addColorStop(1, '#000000'); // 底部黑
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,128,128);
                
                const tex = new THREE.CanvasTexture(canvas);
                // 简单的作弊方法：把这张图设为背景，虽然不是真正的全景，但金属能反射出颜色
                scene.environment = tex; 
            }

            function initPostProcessing() {
                // 如果脚本没加载全，就降级处理
                if(typeof THREE.EffectComposer === 'undefined') return;

                const renderScene = new THREE.RenderPass(scene, camera);
                
                // 辉光参数
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.5;
                bloomPass.strength = 0.8; // 强辉光
                bloomPass.radius = 0.5;

                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            }

            function createLighting() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambient);

                const spot = new THREE.SpotLight(0xffaa00, 1000);
                spot.position.set(20, 50, 20);
                spot.angle = 0.5;
                spot.penumbra = 1;
                scene.add(spot);
                
                const blueSpot = new THREE.SpotLight(0x0000ff, 500);
                blueSpot.position.set(-20, 0, 20);
                scene.add(blueSpot);
                
                // 内部发光点
                const point = new THREE.PointLight(0xffaa00, 5, 20);
                mainGroup.add(point);
            }

            function createContent() {
                // 材质
                const matGold = new THREE.MeshStandardMaterial({ 
                    color: config.gold, roughness: 0.1, metalness: 0.9 
                });
                const matRed = new THREE.MeshPhysicalMaterial({ 
                    color: config.red, roughness: 0.2, metalness: 0.2, clearcoat: 1.0 
                });
                
                const geoBox = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const geoSphere = new THREE.SphereGeometry(0.25, 16, 16);

                // 粒子
                for(let i=0; i<1500; i++) {
                    const isGold = Math.random() > 0.4;
                    const mesh = new THREE.Mesh(
                        isGold ? geoBox : geoSphere, 
                        isGold ? matGold : matRed
                    );
                    
                    // 初始位置
                    mesh.position.set(
                        (Math.random()-0.5)*50, 
                        (Math.random()-0.5)*50, 
                        (Math.random()-0.5)*50
                    );

                    // 计算树的形状
                    const t = i / 1500;
                    const angle = t * 50 * Math.PI;
                    const h = t * 35 - 17;
                    const r = 14 * (1 - Math.pow(t, 0.8));
                    
                    const treePos = new THREE.Vector3(
                        Math.cos(angle) * r,
                        h,
                        Math.sin(angle) * r
                    );

                    mesh.userData = {
                        treePos: treePos,
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05),
                        speed: Math.random() * 0.02
                    };
                    
                    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                    mainGroup.add(mesh);
                    particles.push(mesh);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                
                // 鼠标交互旋转
                mainGroup.rotation.y += (rotationTarget.y - mainGroup.rotation.y) * 0.05;
                mainGroup.rotation.x += (rotationTarget.x - mainGroup.rotation.x) * 0.05;

                // 粒子动画
                particles.forEach(p => {
                    p.rotation.x += p.userData.speed;
                    p.rotation.y += p.userData.speed;

                    if (mode === 'SCATTER') {
                        p.position.add(p.userData.velocity);
                        if(p.position.length() > 25) p.userData.velocity.negate();
                    } else {
                        // 移动回树的形状
                        p.position.lerp(p.userData.treePos, 0.05);
                    }
                });

                // 渲染
                if (composer) composer.render();
                else renderer.render(scene, camera);
            }

            function bindEvents() {
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });
                
                window.addEventListener('mousemove', (e) => {
                    rotationTarget.y = (e.clientX / window.innerWidth - 0.5) * 1.5;
                    rotationTarget.x = (e.clientY / window.innerHeight - 0.5) * 0.5;
                });
            }

            return {
                start: init,
                toggleMode: () => { 
                    mode = mode === 'TREE' ? 'SCATTER' : 'TREE'; 
                }
            };
        }();

        // 启动应用
        App.start();

    </script>
</body>
</html>
