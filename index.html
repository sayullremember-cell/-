<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree - Debug Version</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root { --gold: #d4af37; --cream: #fceea7; --bg: #000000; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Times New Roman', serif; color: var(--cream); user-select: none; }
        
        /* UI Layer */
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; transition: opacity 0.5s ease; }
        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }
        h1 { font-family: 'Cinzel', serif; font-size: 56px; text-align: center; margin-top: 40px; background: linear-gradient(to bottom, #ffffff 0%, var(--gold) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.6)); text-transform: uppercase; letter-spacing: 4px; }
        
        .controls-wrapper { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: auto; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .upload-btn { background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); border: 1px solid var(--gold); color: var(--gold); padding: 12px 30px; font-family: 'Cinzel', serif; font-size: 16px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 2px; }
        .upload-btn:hover { background: rgba(212, 175, 55, 0.2); box-shadow: 0 0 15px var(--gold); }
        .hint-text { font-size: 12px; color: rgba(252, 238, 167, 0.6); letter-spacing: 1px; }

        /* Loader */
        #loader { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s ease-out; }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.3); border-top: 2px solid var(--gold); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        .loader-text { font-family: 'Cinzel', serif; color: var(--gold); font-size: 14px; letter-spacing: 3px; margin-bottom: 20px; }
        .skip-btn { background: transparent; border: 1px solid rgba(212, 175, 55, 0.5); color: rgba(212, 175, 55, 0.7); padding: 8px 16px; font-size: 12px; cursor: pointer; margin-top: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Debug Console (屏幕上的报错台) */
        #debug-console {
            position: fixed; top: 0; left: 0; width: 100%; max-height: 200px;
            overflow-y: auto; background: rgba(0,0,0,0.8); color: #0f0;
            font-family: monospace; font-size: 10px; z-index: 10000;
            pointer-events: none; display: none; padding: 5px;
        }
        .log-error { color: #ff3333; }
        .log-info { color: #ffff33; }

        @media (max-width: 600px) { h1 { font-size: 32px; } }
    </style>

    <!-- 诊断脚本：把错误打印到屏幕上 -->
    <script>
        window.onerror = function(msg, url, line) {
            var consoleDiv = document.getElementById('debug-console');
            if(consoleDiv) {
                consoleDiv.style.display = 'block';
                consoleDiv.innerHTML += '<div class="log-error">❌ ' + msg + ' (Line: ' + line + ')</div>';
            }
        };
        window.logToScreen = function(msg, type='info') {
            var consoleDiv = document.getElementById('debug-console');
            if(consoleDiv) {
                if(type === 'error') consoleDiv.style.display = 'block';
                consoleDiv.innerHTML += '<div class="log-'+type+'">' + msg + '</div>';
            }
        }
    </script>

    <!-- 更加稳定的 Import Map (使用 unpkg 和 esm.sh) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>
</head>
<body>

    <div id="debug-console"></div>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">INITIALIZING...</div>
        <button class="skip-btn" onclick="document.getElementById('loader').style.display='none'">FORCE ENTER</button>
    </div>

    <div id="ui-container">
        <h1>Merry Christmas</h1>
        <div class="controls-wrapper">
            <button class="upload-btn" onclick="document.getElementById('imageInput').click()">ADD MEMORIES</button>
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
            <div id="status-text" class="hint-text">Mode: TREE (Interact with Mouse/Hand)</div>
        </div>
    </div>

    <!-- 隐形视频容器 -->
    <video id="webcam" autoplay playsinline style="position:absolute; bottom:0; right:0; opacity:0; pointer-events:none; width:1px; height:1px;"></video>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { PMREMGenerator } from 'three/addons/pmrem/PMREMGenerator.js';

        // 注意：MediaPipe 改为动态加载，防止一开始就卡死
        
        window.logToScreen("Three.js loaded successfully.", "info");

        // --- GLOBAL STATE ---
        const STATE = {
            mode: 'TREE', 
            rotation: { x: 0, y: 0 },
            targetPhotoIndex: -1,
            time: 0,
            usingMouse: true // 默认先用鼠标
        };

        // --- SCENE ---
        class ChristmasScene {
            constructor() {
                try {
                    this.init();
                    this.createLighting();
                    this.createContent();
                    this.createPostProcessing();
                    this.animate();
                    this.bindEvents();
                    
                    // Remove Loader immediately after 3D init
                    setTimeout(() => {
                        const l = document.getElementById('loader');
                        if(l) { l.style.opacity = '0'; setTimeout(()=>l.remove(), 800); }
                    }, 500);

                } catch(e) {
                    window.logToScreen("Scene Init Error: " + e.message, "error");
                    console.error(e);
                }
            }

            init() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 优化性能
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                document.body.appendChild(this.renderer.domElement);

                this.scene = new THREE.Scene();
                this.mainGroup = new THREE.Group();
                this.scene.add(this.mainGroup);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 2, 50);

                // Environment
                const pmremGenerator = new PMREMGenerator(this.renderer);
                this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment()).texture;
            }

            createLighting() {
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const point = new THREE.PointLight(0xffaa00, 2, 50);
                this.mainGroup.add(point);
                const spot = new THREE.SpotLight(0xd4af37, 1000);
                spot.position.set(30, 40, 40);
                this.scene.add(spot);
            }

            createContent() {
                // Shared Geometries & Materials
                const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const sphereGeo = new THREE.SphereGeometry(0.2, 16, 16);
                const matGold = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.2, metalness: 0.8 });
                const matRed = new THREE.MeshPhysicalMaterial({ color: 0xcc0000, metalness: 0.1, roughness: 0.2, clearcoat: 1.0 });
                const matGreen = new THREE.MeshStandardMaterial({ color: 0x1a472a, roughness: 0.7 });

                this.particles = [];
                this.photos = [];

                // Create 1200 particles
                for (let i = 0; i < 1200; i++) {
                    let mesh, type;
                    const r = Math.random();
                    if (r < 0.5) { mesh = new THREE.Mesh(sphereGeo, r > 0.5 ? matGold : matRed); type = 'SPHERE'; }
                    else { mesh = new THREE.Mesh(boxGeo, r > 0.5 ? matGold : matGreen); type = 'BOX'; }

                    mesh.position.set((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
                    mesh.userData = {
                        type: type,
                        velocity: new THREE.Vector3((Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05),
                        treePos: this.calculateTreePos(i, 1200),
                        id: i
                    };
                    this.mainGroup.add(mesh);
                    this.particles.push(mesh);
                }
                
                // Add default photo
                this.addPhoto();
            }

            calculateTreePos(index, total) {
                const t = index / total;
                const angle = t * 40 * Math.PI;
                const height = t * 30 - 15;
                const radius = 12 * (1 - t);
                return new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle));
            }

            addPhoto(url) {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 320;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fceea7'; ctx.fillRect(0,0,256,320);
                ctx.strokeStyle = '#d4af37'; ctx.lineWidth=10; ctx.strokeRect(5,5,246,310);
                ctx.fillStyle = '#d4af37'; ctx.font='30px serif'; ctx.textAlign='center'; 
                ctx.fillText("JOYEUX", 128, 140); ctx.fillText("NOEL", 128, 180);
                
                const tex = url ? new THREE.TextureLoader().load(url) : new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 0.1), [
                    new THREE.MeshStandardMaterial({color:0xd4af37}), new THREE.MeshStandardMaterial({color:0xd4af37}),
                    new THREE.MeshStandardMaterial({color:0xd4af37}), new THREE.MeshStandardMaterial({color:0xd4af37}),
                    new THREE.MeshBasicMaterial({ map: tex }), new THREE.MeshStandardMaterial({color:0xd4af37})
                ]);
                mesh.userData = { type: 'PHOTO', treePos: new THREE.Vector3(0, 16, 0), velocity: new THREE.Vector3(0,0,0) };
                this.mainGroup.add(mesh);
                this.particles.push(mesh);
                this.photos.push(mesh);
            }

            createPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.8));
            }

            update() {
                STATE.time += 0.01;
                this.mainGroup.rotation.y = THREE.MathUtils.lerp(this.mainGroup.rotation.y, STATE.rotation.y, 0.1);
                this.mainGroup.rotation.x = THREE.MathUtils.lerp(this.mainGroup.rotation.x, STATE.rotation.x, 0.1);

                this.particles.forEach(p => {
                    let target = p.userData.treePos;
                    if (STATE.mode === 'SCATTER') {
                        p.position.add(p.userData.velocity);
                        if(p.position.length() > 20) p.userData.velocity.negate();
                        p.rotation.x += 0.02;
                        return;
                    }
                    if (STATE.mode === 'FOCUS' && p.userData.type === 'PHOTO') {
                         target = new THREE.Vector3(0, 2, 35);
                         p.lookAt(this.camera.position);
                         p.scale.setScalar(4);
                    } else {
                         p.scale.setScalar(1);
                    }
                    p.position.lerp(target, 0.05);
                    if(STATE.mode === 'TREE') p.rotation.y += 0.02;
                });
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.update();
                this.composer.render();
            }

            bindEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });
                window.addEventListener('mousemove', (e) => {
                    if(STATE.usingMouse) {
                        STATE.rotation.y = (e.clientX / window.innerWidth - 0.5) * 1.5;
                        STATE.rotation.x = (e.clientY / window.innerHeight - 0.5) * 1.5;
                    }
                });
                window.addEventListener('click', () => {
                     STATE.mode = STATE.mode === 'TREE' ? 'SCATTER' : (STATE.mode === 'SCATTER' ? 'FOCUS' : 'TREE');
                     document.getElementById('status-text').innerText = "Mode: " + STATE.mode;
                });
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    const f = e.target.files[0];
                    if(f) {
                        const reader = new FileReader();
                        reader.onload = (ev) => this.addPhoto(ev.target.result);
                        reader.readAsDataURL(f);
                    }
                });
            }
        }

        // --- START APP ---
        const app = new ChristmasScene();

        // --- LAZY LOAD AI ---
        (async function loadVision() {
            try {
                window.logToScreen("Loading AI Module...", "info");
                // 动态导入，避免阻塞
                const { FilesetResolver, HandLandmarker } = await import('@mediapipe/tasks-vision');
                
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                const landmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                window.logToScreen("AI Loaded! Starting Camera...", "info");
                
                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 160, height: 120 } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    STATE.usingMouse = false;
                    document.getElementById('status-text').innerText = "Mode: TREE (Hand Control Active)";
                    window.logToScreen("Hand Tracking Active!", "info");
                    
                    let lastTime = -1;
                    function predict() {
                        requestAnimationFrame(predict);
                        if (video.currentTime !== lastTime) {
                            lastTime = video.currentTime;
                            const result = landmarker.detectForVideo(video, performance.now());
                            if (result.landmarks && result.landmarks.length > 0) {
                                const palm = result.landmarks[0][9];
                                STATE.rotation.y = (palm.x - 0.5) * 2;
                                STATE.rotation.x = (palm.y - 0.5) * 2;
                                // 简单的手势检测逻辑
                                const thumb = result.landmarks[0][4];
                                const index = result.landmarks[0][8];
                                if (Math.hypot(thumb.x-index.x, thumb.y-index.y) < 0.05) STATE.mode = 'FOCUS';
                                else STATE.mode = 'TREE'; 
                            }
                        }
                    }
                    predict();
                });

            } catch (e) {
                window.logToScreen("AI Load Failed: " + e.message, "error");
                console.warn("Vision failed, fallback to mouse.");
            }
        })();

    </script>
</body>
</html>
